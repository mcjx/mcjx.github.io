[{"title":"gulp制作css雪碧图","date":"2017-11-08T05:31:50.000Z","path":"2017/11/08/gulp制作css精灵图/","text":"在Web前端开发的过程中，Web页面加载是性能杀手，解决了Web页面加载的问题，前端工程的性能可以提升80%左右，所以，使用一些比较好的工具，引入一些比较先进的思想是很有必要的。这篇博客就介绍一下使用gulp来制作雪碧图。 雪碧图（sprite）是把多张图片拼到一张图中，提升性能的一种做法。把合并的图片一次性加载到内存中，需要时只渲染一部分。大大提高了页面响应速度。 准备工作 安装gulp：cnpm install gulp –save-dev 安装雪碧图需要的插件：cnpm install –save-dev gulp.spritesmith 建立package.json文件 新建gulpfile.js详情点击 要生成的图片： gulpfile.js12345678910111213var gulp=require('gulp'); spritesmith=require('gulp.spritesmith'); gulp.task('sprite',function()&#123; gulp.src('src/images/*.png') .pipe(spritesmith(&#123; imgName:'sprite.png', cssName:'css/sprite.css', padding:5, algorithm:'binary-tree' &#125;)) .pipe(gulp.dest('dist/')) &#125;) 解释一下这个js，首先，我们引用了gulp和spritesmith这个插件，接着新建名为sprite的任务，我们需要合成雪碧图的文件在src的images文件夹里，“*”为通配符，表示这个文件夹里所有.png格式的文件都会被使用。然后，我们把这个任务放到通道（gulp机制）里，imgName为生成图的名称，css为对应生成的css文件，padding表示合成时两个图片的间距。在这里要说一下algorithm，他有四个可选值，分别为top-down、left-right、diagonal、alt-diagonal、binary-tree，表现形式如下： 最后，把生成的文件放到dist文件夹下，效果如下： 生成的css123456789101112131415161718.icon-0 &#123; background-image: url(../sprite.png); background-position: 0px 0px; width: 59px; height: 60px; &#125; .icon-1 &#123; background-image: url(../sprite.png); background-position: 0px -65px; width: 57px; height: 55px; &#125; .icon-2 &#123; background-image: url(../sprite.png); background-position: -64px 0px; width: 62px; height: 54px; &#125; 至此，基本的雪碧图就生成好了，当然，如果还想有更多的样式，我们可以引入模板cssTemplate或者直接写个函数 样式模板12345678&#123;&#123;#sprites&#125;&#125;//模板，直接在JS里面根据路径调用即可，#代表循环 .icon-&#123;&#123;name&#125;&#125;&#123; background-image: url(\"&#123;&#123;escaped_image&#125;&#125;\"); background-position: &#123;&#123;px.offset_x&#125;&#125; &#123;&#123;px.offset_y&#125;&#125;; width: &#123;&#123;px.width&#125;&#125;; height: &#123;&#123;px.height&#125;&#125;; &#125; &#123;&#123;/sprites&#125;&#125; 12345678910111213cssTemplate: function (data) &#123;//函数，直接写到gulpfile.js文件即可。 var arr=[]; data.sprites.forEach(function (sprite) &#123; arr.push(\".icon-\"+sprite.name+ \"&#123;\" + \"background-image: url('\"+sprite.escaped_image+\"');\"+ \"background-position: \"+sprite.px.offset_x+\"px \"+sprite.px.offset_y+\"px;\"+ \"width:\"+sprite.px.width+\";\"+ \"height:\"+sprite.px.height+\";\"+ \"&#125;\\n\"); &#125;); return arr.join(\"\"); &#125;","tags":[{"name":"随笔","slug":"随笔","permalink":"http://liangronghua.com/tags/随笔/"},{"name":"gulp","slug":"gulp","permalink":"http://liangronghua.com/tags/gulp/"}]},{"title":"用gulp构建项目","date":"2017-09-09T13:51:50.000Z","path":"2017/09/09/gulp搭建项目/","text":"gulp.js 是一种基于流的，代码优于配置的新一代构建工具。Gulp 和 Grunt 类似。但相比于 Grunt 的频繁的 IO 操作，Gulp 的流操作，能更快地完成构建，本文将介绍几种常用插件的使用方法 匹配符 *、**、！、{} 1234gulp.src('./js/*.js') // * 匹配js文件夹下所有.js格式的文件gulp.src('./js/**/*.js') // ** 匹配js文件夹的0个或多个子文件夹gulp.src(['./js/*.js','!./js/index.js']) // ! 匹配除了index.js之外的所有js文件gulp.src('./js/**/&#123;omui,common&#125;.js') // &#123;&#125; 匹配&#123;&#125;里的文件名 文件操作 12345del (替代gulp-clean)var del = require('del');del('./dist'); // 删除整个dist文件夹 gulp-sass 编译sass 12345678910var sass = require('gulp-sass');gulp.task('sass',function() &#123; gulp.src('./sass/**/*.scss') .pipe(sass(&#123; outputStyle: 'compressed' // 配置输出方式,默认为nested &#125;)) .pipe(gulp.dest('./dist/css'));&#125;); gulp.watch('./sass/**/*.scss', ['sass']); // 实时监听sass文件变动,执行sass任务 gulp-babel 将ES6代码编译成ES5 123456789var babel = require('gulp-babel');gulp.task('es6',function() &#123; gulp.src('./js/index.js') .pipe(babel(&#123; presets: ['es2015'] &#125;)) .pipe(gulp.dest('./dist'))&#125;); gulp-rename 重命名文件。 12345678910111213141516171819var rename = require(\"gulp-rename\");gulp.task('rename',function() &#123; gulp.src('./hello.txt') .pipe(rename('gb/goodbye.md')) // 直接修改文件名和路径 .pipe(gulp.dest('./dist')); &#125;);gulp.task('rename2',function() &#123; gulp.src('./hello.txt') .pipe(rename(&#123; dirname: \"text\", // 路径名 basename: \"goodbye\", // 主文件名 prefix: \"pre-\", // 前缀 suffix: \"-min\", // 后缀 extname: \".html\" // 扩展名 &#125;)) .pipe(gulp.dest('./dist'));&#125;); gulp-uglify 压缩js文件 1234567891011121314151617var uglify = require(\"gulp-uglify\");gulp.task('uglify',function() &#123; gulp.src('./hello.js') .pipe(uglify()) // 直接压缩hello.js .pipe(gulp.dest('./dist'))&#125;);gulp.task('uglify2',function() &#123; gulp.src('./hello.js') .pipe(uglify(&#123; mangle: true, // 是否修改变量名，默认为 true compress: true, // 是否完全压缩，默认为 true preserveComments: 'all' // 保留所有注释 &#125;)) .pipe(gulp.dest('./dist'))&#125;); gulp-csso 压缩优化css。 1234567var csso = require('gulp-csso');gulp.task('minifycss',function() &#123; gulp.src('./css/*.css') .pipe(csso()) .pipe(gulp.dest('./dist/css'))&#125;); gulp-html-minify 压缩HTML。 1234567var htmlminify = require('gulp-html-minify');gulp.task('minifyhtml',function() &#123; gulp.src('index.html') .pipe(htmlminify()) .pipe(gulp.dest('./dist'))&#125;); gulp-imagemin 压缩图片 1234567var imagemin = require('gulp-imagemin');gulp.task('minifyimg',function() &#123; gulp.src('./img/*.&#123;jpg,png,gif,ico&#125;') .pipe(imagemin()) .pipe(gulp.dest('./dist/img'))&#125;); gulp-zip ZIP压缩文件 1234567var zip = require('gulp-zip');gulp.task('zip',function() &#123; gulp.src('./src/*') .pipe(zip('all.zip')) // 压缩成all.zip文件 .pipe(gulp.dest('./dist'))&#125;); gulp-autoprefixer 自动为css添加浏览器前缀 12345678910111213141516171819var autoprefixer = require('gulp-autoprefixer');gulp.task('autoprefixer',function() &#123; gulp.src('./css/*.css') .pipe(autoprefixer()) // 直接添加前缀 .pipe(gulp.dest('dist'))&#125;);gulp.task('autoprefixer2',function() &#123; gulp.src('./css/*.css') .pipe(autoprefixer(&#123; browsers: ['last 2 versions'], // 浏览器版本 cascade：true // 美化属性，默认true add: true // 是否添加前缀，默认true remove: true // 删除过时前缀，默认true flexbox: true // 为flexbox属性添加前缀，默认true &#125;)) .pipe(gulp.dest('./dist'))&#125;); gulp-concat 合并文件。 12345678910111213var concat = require('gulp-concat');gulp.task('concat',function() &#123; gulp.src('./js/*.js') .pipe(concat('all.js')) // 合并all.js文件 .pipe(gulp.dest('./dist'));&#125;);gulp.task('concat2',function() &#123; gulp.src(['./js/demo1.js','./js/demo2.js','./js/demo2.js']) .pipe(concat('all.js')) // 按照[]里的顺序合并文件 .pipe(gulp.dest('./dist'));&#125;); gulp-asset-rev 给静态资源文件名添加hash值 这里需要修改一下源文件，该插件默认在文件名后面“.”之前加字符串，如果要在后缀名后面加hash值，需要做一些修改，打开 node_modules/gulp-asset-rev/index.js 12345678// 在文件名后加哈希值: src=\"xx/index-hhgjshdhfd.js\"// var verStr = (options.verConnecter || \"-\") + md5;// src = src.replace(verStr, '').replace(/(\\.[^\\.]+)$/, verStr + \"$1\");// 修改为// 在文件名url后加哈希值: src=\"xx/index.js?v=hhgjshdhfd\"var verStr = (options.verConnecter || \"\") + md5;src=src+\"?v=\"+verStr; 1234567var rev = require('gulp-asset-rev');gulp.task('addhash',function() &#123; gulp.src(\"./src/*.html\") .pipe(assetRev()) .pipe(gulp.dest('./dist'));&#125;); gulp-rev-replace 重写被gulp-rev重命名的文件名 1234567891011var rev = require('gulp-rev');var revReplace = require('gulp-rev-replace');var useref = require('gulp-useref');gulp.task('rebuild',function() &#123; gulp.src('index.html') .pipe(useref()) // 替换HTML中引用的css和js .pipe(rev()) // 给css,js,html加上hash版本号 .pipe(revReplace()) // 把引用的css和js替换成有版本号的名字 .pipe(gulp.dest('./dist'))&#125;); gulp-connect vinyl-source-stream 热加载 123456789101112131415// 重载htmlgulp.task('html', function () &#123; gulp.src('./src/*.html') .pipe(connect.reload()); // 重新加载&#125;);//实时刷新页面gulp.task('connect', function () &#123; connect.server(&#123; //host: '192.168.1.110', //地址，可不写，不写的话，默认localhost port: 8080, //端口号，可不写，默认8000 root: 'src', livereload: true //自动刷新 &#125;);&#125;); gulp-html-replace 替换html中的构建块 123456// index.html&lt;!-- build:css --&gt; // css是buildName,可以自己定义&lt;link rel=\"stylesheet\" href=\"css/normalize.css\"&gt;&lt;link rel=\"stylesheet\" href=\"css/main.css\"&gt;&lt;!-- endbuild --&gt; 1234567891011// gulpfile.jsvar htmlreplace = require('gulp-html-replace');gulp.task('htmlreplace',function() &#123; gulp.src('index.html') .pipe(htmlreplace(&#123; 'css':'all.css' // css是index.html中定义的buildName &#125;)) .pipe(gulp.dest('./dist'))&#125;); 替换之后的index.html中就会变成： 1&lt;link rel=\"stylesheet\" href=\"all.css\"&gt; // 之前的两个&lt;link&gt;替换成一个了 gulp-if 流控制，有条件地运行一个任务 12345678910var gulpif = require('gulp-if');var uglify = require('gulp-uglify');var concat = require('gulp-concat');var condition = true; gulp.task('gulpif',function() &#123; gulp.src('./js/*.js') .pipe(gulpif(condition, uglify(), concat('all.js'))) // condition为true时执行uglify(), else 执行concat('all.js') .pipe(gulp.dest('./dist/'));&#125;); gulp-load-plugins 从包的依赖和附件里加载gulp插件到一个对象里给你选择 12345678// package.json \"devDependencies\": &#123; \"gulp\": \"^3.9.1\", \"gulp-concat\": \"^2.6.1\", \"gulp-rename\": \"^1.2.2\", \"gulp-uglify\": \"^2.0.1\"&#125; 1234567891011// gulpfile.jsvar $ = require('gulp-load-plugins')(); // $ 是一个对象,加载了依赖里的插件gulp.task('htmlreplace',function() &#123; gulp.src('./**/*.js') .pipe($.concat('all.js')) // 使用插件就可以用$.PluginsName() .pipe($.uglify()) .pipe($.rename('all.min.js')) .pipe(gulp.dest('./dist'))&#125;);","tags":[{"name":"笔记","slug":"笔记","permalink":"http://liangronghua.com/tags/笔记/"},{"name":"自动化","slug":"自动化","permalink":"http://liangronghua.com/tags/自动化/"}]},{"title":"js对象入门","date":"2017-07-28T13:51:50.000Z","path":"2017/07/28/js对象解析/","text":"一切事物皆对象 对象具有封装和继承特性 对象与对象之间使用消息通信，各自存在信息隐藏 javascript 创建对象简单的来说，无非就是使用内置对象或各种自定义对象，当然还可以使用JSON，但写法有很多，也能混合使用。 一、 生成实例对象的原始模式假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。 1234var Cat = &#123; name : '', color : ''&#125; 现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。 123456var cat1 = &#123;&#125;; // 创建一个空对象 cat1.name = \"大毛\"; // 按照原型对象的属性赋值 cat1.color = \"黄色\";var cat2 = &#123;&#125;; cat2.name = \"二毛\"; cat2.color = \"黑色\"; 好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。 二、 原始模式的改进我们可以写一个函数，解决代码重复的问题。 123456function Cat(name,color) &#123; return &#123; name:name, color:color &#125;&#125; 然后生成实例对象，就等于是在调用函数： 12var cat1 = Cat(\"大毛\",\"黄色\");var cat2 = Cat(\"二毛\",\"黑色\"); 这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。 三、 构造函数模式为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。比如，猫的原型对象现在可以这样写， 1234function Cat(name,color)&#123; this.name=name; this.color=color;&#125; 我们现在就可以生成实例对象了。 1234var cat1 = new Cat(\"大毛\",\"黄色\");var cat2 = new Cat(\"二毛\",\"黑色\");alert(cat1.name); // 大毛alert(cat1.color); // 黄色 这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。 12alert(cat1.constructor == Cat); //truealert(cat2.constructor == Cat); //true Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。 12alert(cat1 instanceof Cat); //truealert(cat2 instanceof Cat); //true 四、构造函数模式的问题构造函数方法很好用，但是存在一个浪费内存的问题。请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样： 123456function Cat(name,color)&#123; this.name = name; this.color = color; this.type = \"猫科动物\"; this.eat = function()&#123;alert(\"吃老鼠\");&#125;;&#125; 还是采用同样的方法，生成实例： 1234var cat1 = new Cat(\"大毛\",\"黄色\");var cat2 = new Cat (\"二毛\",\"黑色\");alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠 表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。 1alert(cat1.eat == cat2.eat); //false 能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。 五、 Prototype模式Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。 123456function Cat(name,color)&#123; this.name = name; this.color = color;&#125;Cat.prototype.type = \"猫科动物\";Cat.prototype.eat = function()&#123;alert(\"吃老鼠\")&#125;; 然后，生成实例。 1234var cat1 = new Cat(\"大毛\",\"黄色\");var cat2 = new Cat(\"二毛\",\"黑色\");alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠 这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。 1alert(cat1.eat == cat2.eat); //true 六、 Prototype模式的验证方法为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。 6.1 isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。 12alert(Cat.prototype.isPrototypeOf(cat1)); //truealert(Cat.prototype.isPrototypeOf(cat2)); //true 6.2 hasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。 12alert(cat1.hasOwnProperty(\"name\")); // truealert(cat1.hasOwnProperty(\"type\")); // false 6.3 in运算符in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。 12alert(\"name\" in cat1); // truealert(\"type\" in cat1); // true in运算符还可以用来遍历某个对象的所有属性。 123for(var prop in cat1) &#123; alert(\"cat1[\"+prop+\"]=\"+cat1[prop]); &#125; 七、构造函数的继承比如，现在有一个”动物”对象的构造函数。 123function Animal()&#123; this.species = \"动物\"; &#125; 还有一个”猫”对象的构造函数。 1234function Cat(name,color)&#123; this.name = name; this.color = color; &#125; 怎样才能使”猫”继承”动物”呢？ 7.1 构造函数绑定第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行： 1234567function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125;var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物 7.2 prototype模式第二种方法更常见，使用prototype属性。如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。 1234Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物 代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。 1Cat.prototype = new Animal(); 它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？ 1Cat.prototype.constructor = Cat; 原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有 1\"Cat.prototype = new Animal();\" 这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。 1alert(Cat.prototype.constructor == Animal); //true 更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。 1alert(cat1.constructor == Cat.prototype.constructor); // true 因此，在运行”Cat.prototype = new Animal();”这一行之后，cat1.constructor也指向Animal！ 1alert(cat1.constructor == Animal); // true 这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象， 1o.prototype = &#123;&#125;; 那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。 1o.prototype.constructor = o; 7.3 直接继承prototype第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。现在，我们先将Animal对象改写： 12function Animal()&#123; &#125;Animal.prototype.species = \"动物\"; 然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。 1234Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat;var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物 与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。所以，上面这一段代码其实是有问题的。请看第二行 1Cat.prototype.constructor = Cat; 这一句实际上把Animal.prototype对象的constructor属性也改掉了！ 1alert(Animal.prototype.constructor); // Cat 7.4 利用空对象作为中介由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。 1234var F = function()&#123;&#125;;F.prototype = Animal.prototype;Cat.prototype = new F();Cat.prototype.constructor = Cat; F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。 1alert(Animal.prototype.constructor); // Animal 我们将上面的方法，封装成一个函数，便于使用。 12345678function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 使用的时候，方法如下 123extend(Cat,Animal);var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物 这个extend函数，就是YUI库如何实现继承的方法。另外，说明一点，函数体最后一行 1Child.uber = Parent.prototype; 意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。五、 拷贝继承上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。首先，还是把Animal的所有不变属性，都放到它的prototype对象上。 12function Animal()&#123;&#125;Animal.prototype.species = \"动物\"; 然后，再写一个函数，实现属性拷贝的目的。 12345678function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p;&#125; 这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。使用的时候，这样写： 123extend2(Cat, Animal);var cat1 = new Cat(\"大毛\",\"黄色\");alert(cat1.species); // 动物","tags":[{"name":"笔记","slug":"笔记","permalink":"http://liangronghua.com/tags/笔记/"},{"name":"js","slug":"js","permalink":"http://liangronghua.com/tags/js/"}]},{"title":"前端经典代码，让编程更简单","date":"2017-06-28T13:51:50.000Z","path":"2017/06/28/前端经典代码/","text":"作为一名程序员，每天坐在电脑前敲敲打打那些重复重复再重复的语句，习惯性的思维总是被套进去，有些时候很容易把简单的事情想复杂了！不过，我们反其道而行之，新手们只要是把下面的语句牢记，很多情况下都是会事半功倍的！ 将彻底屏蔽鼠标右键，无右键菜单 1&lt;body oncontextmenu=\"window.event.returnvalue=false\"&gt; 也可以用于网页中Table框架中 1&lt;table border oncontextmenu=\"return false\"&gt;&lt;td&gt;no&lt;/table&gt; 取消选取、防止复制 1&lt;body onselectstart=\"return false\"&gt; 不准粘贴 1&lt;body onpaste=\"return false\"&gt; 防止复制 1&lt;body oncopy=\"return false\"; oncut=\"return false\";&gt; IE地址栏前换成自己的图标 1&lt;link rel=\"Shortcut Icon\" href=\"favicon.ico\"&gt; 说明：关于favicon.ico文件的制作。你可以先在FW中做一个图片，属于你自己站点一个小图标。然后在ACD see将文件属性改为.ico，然后将你做的.ICO文件传到你的服务器目录中，然后就可以使用以上代码来实现，当别人登陆你的站点时，地址栏里使用的就是你自定义的图标了。 可以在收藏夹中显示出你的图标 1&lt;link rel=\"Bookmark\" href=\"favicon.ico\"&gt; 说明：制作方法和上面的一样。只是显示的方式不同，这个是在别人收藏你的网页地址时显示的个性图标。 关闭输入法 1&lt;input style=\"ime-mode:disabled\"&gt; 说明：这段代码是在表格提交时用到的。也就是在输入数据时不可以使用其他输入法模式。 永远都会带着框架 123&lt;script language=\"javascript\"&gt;&lt;!-- if (window == top)top.location.href = frames.htm;// --&gt;&lt;/script&gt; 说明：frames.htm为你的网页，这也是保护页面的一种方法 防止被人frame 123&lt;script language=\"javascript\"&gt;&lt;!-- if (top.location != self.location)top.location=self.location;// --&gt;&lt;/script&gt; 网页将不能被另存为 1&lt;noscript&gt;&lt;iframe src=\"*.html\"&gt;&lt;/iframe&gt;&lt;/noscript&gt; 说明：的用法很广，其中一条就是可以使JS广告失效。 内框架 iframe 使用 iframe标记的使用格式是: 1&lt;iframe src=\"URL\" width=x height=x scrolling=\"[OPTION]\" frameborder=x name=\"main\"&gt;&lt;/iframe&gt; src：文件的路径，既可是HTML文件，也可以是文本、ASP等 width、height：内部框架区域的宽与高； scrolling：当SRC的指定的HTML文件在指定的区域不显不完时，滚动选项，如果设置为NO，则不出现滚动条；如为Auto：则自动出现滚动条；如为Yes，则显示； FrameBorder：区域边框的宽度，为了让“内部框架“与邻近的内容相融合，常设置为0。 name：框架的名字，用来进行识别。 比如：当你想用父框架控制内部框架时，可以使用： target=框架的名字来控制。 例子： 1&lt;iframe name=\"mm\" src=\"http://bbs.055.cn\" width=100% height=100% marginwidth=0 marginheight= ... ot frameborder=0 scrolling=no&gt;&lt;/iframe&gt; 自动跳转 在源代码中的…加入如下代码： 1&lt;meta http-equiv=\"refreshcontent=3\" URL=\"http://bbs.055.cn\" charset=\"gb2312\"&gt; 说明：content=3表示3秒刷新到URL 如何改变链接的鼠标形状 只需在链接上加上这一代码就行的了,或者跟上面的用CSS写也行 12345678910111213141516171819202122232425style=cursor:handstyle=cursor:crosshairstyle=cursor:textstyle=cursor:waitstyle=cursor:movestyle=cursor:helpstyle=cursor:e-resizestyle=cursor:n-resizestyle=cursor:nw-resizestyle=cursor:w-resizestyle=cursor:s-resizestyle=cursor:se-resizestyle=cursor:sw-resize 以上代码你只需要加到连接或是页面的style区里就可以实现鼠标多样化。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://liangronghua.com/tags/随笔/"},{"name":"笔记","slug":"笔记","permalink":"http://liangronghua.com/tags/笔记/"}]},{"title":"css 滤镜妙用","date":"2017-05-20T13:51:50.000Z","path":"2017/05/20/css滤镜/","text":"CSS3 filter 滤镜为图片提供了非常强大的效果，只需简单地给图片加上 filter 属性，就可以实现 ps 出来的效果。 filter 提供了多种可视效果，而这些效果又可以互相混合，形成新的效果。接下来就用下面这张原图来体验一下 filter 的各种效果。 filter 函数 高斯模糊 blur() 该函数接受一个 css 长度值作为参数，可以是 px/vw/vh/rem 等单位，唯独不能是 % 。值越大越模糊。 1234img&#123; -webkit-filter:blur(5px); filter:blur(5px);&#125; 亮度 brightness() 使图片更亮或者更暗。参数为百分比，默认为1。当参数为 0 时，图片全黑；参数可以大于 100%，也可以写成小数点的形式。 1234img&#123; -webkit-filter:brightness(.5); filter:brightness(.5);&#125; 对比度 contrast() 对比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，差异范围越大代表对比越大，差异范围越小代表对比越小。参数为百分比，默认为1。 1234img&#123; -webkit-filter:contrast(.5); filter:contrast(.5);&#125; 饱和度 saturate() 使图片变暗或更加鲜明。参数为百分比，默认为1，可以大于 100%。 1234img&#123; -webkit-filter:saturate(200%); filter:saturate(200%);&#125; 透明度 opacity() 跟 CSS3 中的 opacity 属性效果是一致的。而使用 filter，一些浏览器为了提升性能会提供硬件加速。 1234img&#123; -webkit-filter:opacity(.5); filter:opacity(.5);&#125; 阴影效果 drop-shadow() 该函数与 CSS3 中的 box-shadow 属性的视觉效果是一致的，参数也跟该属性的值相似。为什么只说相似呢？因为 box-shadow 有个属性值 inset 将阴影效果设为内阴影或者外阴影，而 drop-shadow() 是没有这个参数的。而 spread 参数，兼容却很差，加了也不会渲染，box-shadow 的 spread 值是可以渲染的，所以 drop-shadow() 函数就可以不要写这个参数了。 1234img&#123; -webkit-filter:drop-shadow(5px 5px 5px red); filter:drop-shadow(5px 5px 5px red);&#125; 灰度级 grayscale() 将图像转为灰度图像。参数为百分比，默认为0。若设为 100%，则完全转为灰度图像。 1234img&#123; -webkit-filter:grayscale(1); filter:grayscale(1);&#125; 色相旋转 hue-rotate() 色相是色彩的首要特征，是区别各种不同色彩的最准确的标准。事实上任何黑白灰以外的颜色都有色相的属性，而色相也就是由原色、间色和复色来构成的。hue-rotate() 函数通过旋转角度对色相进行旋转从而改变图像在视觉上的效果。参数为度数，单位为 deg 1234img&#123; -webkit-filter:hue-rotate(180deg); filter:hue-rotate(180deg);&#125; 反色invert() 反色又叫补色，红的补色是绿色，蓝的补色是橙色，黄的补色是紫色，由这三种对比关系可引出很多对比的反色。在“画图”程序中，反色操作是指把画面中的黑色变成白色，白色变成黑色，绿色变成红色，黄色变成紫色。参数为百分比，不能超过 100%。 1234img&#123; -webkit-filter:invert(1); filter:invert(1);&#125; 老照片 sepia() 将图像转换为深褐色，发黄老旧的效果。参数为百分比，默认为 0，不超过 100%。 1234img&#123; -webkit-filter:sepia(.5); filter:sepia(.5);&#125; 复合函数 上面的例子都只是单个效果的展示，而这些效果，都可以混合在一起使用，生成更多的视觉效果。 1234img&#123; -webkit-filter:brightness(120%) contrast(70%) saturate(200%) hue-rotate(30deg) drop-shadow(5px 5px 5px green); filter:brightness(120%) contrast(70%) saturate(200%) hue-rotate(30deg) drop-shadow(5px 5px 5px green);&#125;","tags":[{"name":"随笔","slug":"随笔","permalink":"http://liangronghua.com/tags/随笔/"},{"name":"css","slug":"css","permalink":"http://liangronghua.com/tags/css/"}]},{"title":"css伪元素的作用","date":"2017-03-15T08:34:28.000Z","path":"2017/03/15/css伪元素的作用/","text":"伪元素能做什么？我们要他有何用？它能为我们解决什么问题？和其他的方法相比她有什么有点？我们为什么要使用它？ 伪元素和伪类一样，添加到选择器，但是不是描述状态，他允许我们为元素某些部分设置样式；利用伪元素，我们可以简化页面的html标签，同时用起来也很方便，善于使用伪元素可以让你的页面更加地简洁优雅。之所以叫伪元素，是因为他修饰不在文档树中的部分；不是真实存在的； 伪元素实用小技巧 清除浮动 何谓清除浮动？一个父元素的所有子元素如果都是浮动的，那么这个父元素是没有高度的;父元素并没有脱离正常的文档流，仍然占据正常文档流的空间;如果这个父元素的相邻元素是行内元素，那么这个行内元素将会在这个父元素的区域内见缝插针，找到一块放得下它的地方如果相邻的元素是一个块级元素，那么设置这个块级元素的margin-top将会以这个父元素的起始位置作为起点。 问题：如何解决高度塌陷？ 方法：把父容器的高度撑起来，考虑到浮动了的元素并没有脱离正常文档流，而其它元素会围绕着它环绕，所以清除浮动简单有效的办法就是让环绕的元素不可环绕，把它变成一把尺子，放在最后面，把所有浮动的元素顶起来，而这把尺子就是一个设置了clear的块级元素。因为块级元素会换行，并且设置它两边不能跟着浮动的元素，所以它就跑到浮动元素的下面去，就像一把尺子把浮动元素的内容给顶起来了。而这个可以用一个after实现，因为after就是最后一个子元素： 12345.clearfix:after&#123; content: &quot;&quot;; display: block; clear:both;&#125; 画分割线 在开发中如果我们遇到类似这样的需求我们？我们应该如何只用一个简单的css元素去实现他？ 方案：一个p标签,左右两条线用before和after画出来： 计数器 动态的计算商品的数量，我们经常会借用js来实现；我想告诉css也能实现这个效果，他比js用起来简单多了 counter-reset: 属性创建或者重置一个或多个计数器； counter-increment: 属性递增一个或多个计数器值； content: 与:before 及:after 伪元素配合使用，来插入生成内容。 没有用到一行js代码，你可以试一试;这个主要是结合:checked和counter，用before/after纯CSS实现的，这种纯粹是炫技； 平行四边形 有没有办法只让容器的形状倾斜而保持其内容不变呢？或许你会想到嵌套两层元素，外层skew（）,对内容在应用一次反相skew变形，从而抵消变形的效果。但是意味着我们不得不使用一层额外的HTML元素包裹内容.有些累赘 解决方案：伪元素，把样式应用到伪元素上，对伪元素进行变形，再把伪元素定位+层级放到到住宿元素下面 你也来 试一试 梯形标签页 在网页中我们经常见到梯形形状的标签页，常见的技巧都是比较杂乱，或者说难以维护的，那他们是如何实现的呢？ 解决方案： 三维世界中旋转一个矩形，由于透视关系，我们在二维图像上看到一个梯形，再结合平行四边实现的方法便能实现 perspective: 观察者与z=0平面的距离;对元素使用了3D变形之后，其内部的变形效应是”不可逆转的”，和2D变形不同（2D变形内部的逆向变形可以抵消外部的变形效应）； 为了让他的尺寸更好掌握，我们可以为他指定transform-origin：bottom;也可用scale()对他在进行美观操作； 试一试 多列均匀布局 如何实现下列这种多列均匀布局： 通过给伪元素 :after 设置 inline-block 设置宽度 100% ，配合容器的 text-align: justify 就可以轻松实现多列均匀布局了。 那么为什么使用了 :after 伪元素之后就可以实现对齐了呢？ 原因在于 justify 只有在存在第二行的情况下，第一行才两端对齐，所以在这里，我们需要制造一个假的第二行，而 :after 伪元素正好再适合不过。 需要注意的是img/input等单标签是没有before/after伪元素的，因为是部分 type 不能有，如果你给img添加一个before，那么会被浏览器忽略","tags":[{"name":"随笔","slug":"随笔","permalink":"http://liangronghua.com/tags/随笔/"},{"name":"前端","slug":"前端","permalink":"http://liangronghua.com/tags/前端/"}]},{"title":"git版本管理","date":"2017-01-15T06:09:02.000Z","path":"2017/01/15/git版本管理/","text":"什么是GIT 是一个源代码管理工具 在一个项目中，凡是由开发人员编写的都算是源代码 源代码有必要管理起来？ 让源代码可以被追溯，主要记录每次变更了什么，谁主导这次变化 人为的维护比较麻烦 GIT是Linux之父当年为了维护管理Linux的源代码写的一个工具 Git 之前 很多使用 svn vss tfs hs …… 安装GIT git命令行工具 基于git命令行的一个客户端软件（提供一个界面去管理源代码） GIT命令操作 右键打开 Git Bash 工具，进入项目目录（或直接在项目目录中打开） 初始化一个本地Git仓储 1git init // 初始化一个本地的仓库 初始化后本地文件夹中多了一个.git的文件夹用于记录所有的项目变更信息 查看本地仓储的变更状态 1git status 用于查看本地仓储的状态，第一次查看，显示的是一坨没有被跟踪的文件 1git status -s // -s 是输出简要的变更日志 添加本地暂存（托管）文件 1234git addgit add README.md --&gt;按文件名添加git add *.md --&gt;按通配符添加git add --all --&gt;添加所有文件 可以将一个没有被跟踪的文件添加到跟踪列表 类似于 node_modules 里面这种不需要变动的文件不必要被跟踪 添加本地GIT忽略清单文件 在代码库文件夹的根目录添加一个.gitignore 文件，此文件用于说明忽略的文件有哪些，比如忽略 node_modules 文件夹 1/node_modules 提交被托管的文件变化到本地仓储 1git commit -m &apos;说明修改了哪些内容&apos; 一般在有了一个小单元的整体变化后再提交 对比差异 1git diff 可以用于对比当前状态和版本库中状态的变化 查看提交日志 1git log 回归到指定版本 1git reset --hard 为仓储添加远端地址（如GitHub仓库地址）并起别名 origin 1git remote add origin https://github.com/Micua/Git.git 查看远端地址 1git remote -v 将本地仓储的提交记录推送到远端的master分支 1git push -u origin master 拉取远端master分支的更新记录到本地并合并 1git pull origin master 注意：这个origin不一定是是这个单词，你喜欢就好，包括当面那个git remote add origin git@github.com:yourname/仓库名.git中的origin，相当于你给这个地址起了一个短点的好记的名字，这个命令 是将主分支master提交到远程仓库，当然这个带有 -u 这个参数是指，将master分支的所有内容都提交，第一次关联之后你再提交就可以不用这个参数了，之后你的每一次修改，你就可以只将你修改push就好了 1git push origin master Git克隆远端项目 1git clone https://github.com/Micua/Git.git","tags":[{"name":"随笔","slug":"随笔","permalink":"http://liangronghua.com/tags/随笔/"}]}]